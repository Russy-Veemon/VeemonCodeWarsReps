# Esoteric languages are pretty hard to program, but it's fairly interesting to write interpreters for them!
# Your task is to write a method which will interpret Befunge-93 code! Befunge-93 is a language in which the code is presented not as a series of instructions, but as instructions scattered on a 2D plane; your pointer starts at the top-left corner and defaults to moving right through the code. Note that the instruction pointer wraps around the screen! There is a singular stack which we will assume is unbounded and only contain integers. While Befunge-93 code is supposed to be restricted to 80x25, you need not be concerned with code size. Befunge-93 supports the following instructions (from Wikipedia):
# 0-9 Push this number onto the stack.
# + Addition: Pop a and b, then push a+b.
# - Subtraction: Pop a and b, then push b-a.
# * Multiplication: Pop a and b, then push a*b.
# / Integer division: Pop a and b, then push b/a, rounded down. If a is zero, push zero.
# % Modulo: Pop a and b, then push the b%a. If a is zero, push zero.
# ! Logical NOT: Pop a value. If the value is zero, push 1; otherwise, push zero.
# ` (backtick) Greater than: Pop a and b, then push 1 if b>a, otherwise push zero.
# > Start moving right.
# < Start moving left.
# ^ Start moving up.
# v Start moving down.
# ? Start moving in a random cardinal direction.
# _ Pop a value; move right if value = 0, left otherwise.
# | Pop a value; move down if value = 0, up otherwise.
# " Start string mode: push each character's ASCII value all the way up to the next ".
# : Duplicate value on top of the stack. If there is nothing on top of the stack, push a 0.
# \ Swap two values on top of the stack. If there is only one value, pretend there is an extra 0 on bottom of the stack.
# $ Pop value from the stack and discard it.
# . Pop value and output as an integer.
# , Pop value and output the ASCII character represented by the integer code that is stored in the value.
# # Trampoline: Skip next cell.
# p A "put" call (a way to store a value for later use). Pop y, x and v, then change the character at the position (x,y) in the program to the character with ASCII value v.
# g A "get" call (a way to retrieve data in storage). Pop y and x, then push ASCII value of the character at that position in the program.
# @ End program.
#   (i.e. a space) No-op. Does nothing.
# The above list is slightly modified: you'll notice if you look at the Wikipedia page that we do not use the user input instructions and dividing by zero simply yields zero.
# Here's an example:
# >987v>.v
# v456<  :
# >321 ^ _@
# will create the output 123456789.
# So what you must do is create a function such that when you pass in the Befunge code, the function returns the output that would be generated by the code. So, for example:
# "123456789".equals(new BefungeInterpreter().interpret(">987v>.v\nv456<  :\n>321 ^ _@")
# This test case will be added for you.

import java.util.*;

public class BefungeInterpreter {
    private static final int WIDTH = 80;
    private static final int HEIGHT = 25;
    
    private int[][] grid;
    private Deque<Integer> stack;
    private int x, y;
    private int dx, dy;
    private boolean stringMode;
    private StringBuilder output;
    
    public String interpret(String code) {
        // Initialize grid with spaces
        grid = new int[WIDTH][HEIGHT];
        for (int i = 0; i < WIDTH; i++) {
            for (int j = 0; j < HEIGHT; j++) {
                grid[i][j] = ' ';
            }
        }
        
        // Populate grid with code
        String[] lines = code.split("\n");
        for (int j = 0; j < lines.length; j++) {
            String line = lines[j];
            for (int i = 0; i < line.length(); i++) {
                char c = line.charAt(i);
                grid[i][j] = c;
            }
        }
        
        // Initialize stack and output buffer
        stack = new ArrayDeque<>();
        output = new StringBuilder();
        
        // Initialize instruction pointer
        x = 0;
        y = 0;
        dx = 1;
        dy = 0;
        stringMode = false;
        
        // Execute program
        while (grid[x][y] != '@') {
            int instr = grid[x][y];
            if (stringMode) {
                if (instr == '"') {
                    stringMode = false;
                } else {
                    stack.push(instr);
                }
            } else {
                switch (instr) {
                    case '+':
                        stack.push(stack.pop() + stack.pop());
                        break;
                    case '-':
                        int a = stack.pop();
                        int b = stack.pop();
                        stack.push(b - a);
                        break;
                    case '*':
                        stack.push(stack.pop() * stack.pop());
                        break;
                    case '/':
                        a = stack.pop();
                        b = stack.pop();
                        if (a != 0) {
                            stack.push(b / a);
                        } else {
                            stack.push(0);
                        }
                        break;
                    case '%':
                        a = stack.pop();
                        b = stack.pop();
                        if (a != 0) {
                            stack.push(b % a);
                        } else {
                            stack.push(0);
                        }
                        break;
                    case '!':
                        if (stack.pop() == 0) {
                            stack.push(1);
                        } else {
                            stack.push(0);
                        }
                        break;
                    case '`':
                        a = stack.pop();
                        b = stack.pop();
                        if (b > a) {
                            stack.push(1);
                        } else {
                            stack.push(0);
                        }
                        break;
                    case '>':
                        dx = 1;
                        dy = 0;
                        break;
                    case '<':
                        dx = -1;
                        dy = 0;
                        break;
                    case '^':
                        dx = 0;
                        dy = -1;
                        break;
                    case 'v':
                        dx = 0;
                        dy = 1;
                        break;
                    case '?':
                        int r = (int) (Math.random() * 4);
                        switch (r) {
                            case 0:
                                dx = 1;
                                dy = 0;
                                break;
                            case 1:
                                dx = -1;
                                dy = 0;
                                break;
                            case 
